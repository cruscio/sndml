<doc name="concepts" title="Concepts">
<h2 name="script-mode">Script Mode</h2>
<p>In <b>Script</b> mode the application reads, parses and executes a set of jobs
from a script file.
<b>Script</b> mode is initiated by specifying the following command line option:</p>
<syntax><more><kw>-f</kw><var>filename</var></more></syntax>

<p>Script mode has the following advantages:</p>
<ul>
<li>There are no requirements to install any Update Sets or make any changes 
to your ServiceNow instance.</li>
<li>Since the application only reads (and does not update) your ServiceNow instance,
you may (if you choose) use a SOAP account which lacks write access to the instance.</li>
</ul>

<p>For details on script syntax refer to 
<page name="scripts">this page</page>.</p>

<h2 name="gui-mode">GUI Mode</h2>
<p>In <b>GUI</b> mode the application reads and executes a set of jobs
from the ServiceNow instance.  
<b>GUI</b> mode is initiated by specifying the following command line option:</p>
<syntax><more><kw>-js</kw><var>jobsetname</var></more></syntax>

<p>GUI mode requires you to install an Update Set in your ServiceNow instance.
The Update Set creates tables in your instance which are used to configure the Datapump.
These same tables are also updated as the Datapump runs.</p>
<p>GUI mode has the following advantages:</p>
<ul>
<li>The Datapump is easier to configure.  
You do not need to worry about syntax errors in your script file.</li>
<li>Progress metrics can be viewed in ServiceNow while the Datapump is running.</li>
<li>More configuration options are supported.  For example,
in GUI mode you can configure a job to only process records
that have changed since the last time the job ran.</li>
<li>If a long-running job abends due to a communications error or other issue,
it can be restarted from the point where it failed.  
This is an important feature since ServiceNow is remotely hosted
and the internet is not a highly reliable transport.</li>
</ul>
<p>For information on <b>GUI</b> mode refer to 
<page name="GUI">this page</page>.</p>


<h2>Job</h2>
<p>A <b>Job</b> is a set of instructions for replicating data from a ServiceNow table 
to a target table in an SQL database.  There are various types of jobs as described below.
Each job replicates a single table.  
The set of records to be replicated may be restricted
using a condition (<i>i.e.</i> an encoded query)
and/or a date interval which is based on
<name>sys_updated_on</name> or <name>sys_created_on</name>.</p>
<p>Target tables in the SQL database will be automatically created
if they do not already exist when the job starts.</p>

<h2>JobSet</h2>
<p>A <b>Job Set</b> is a collection of jobs that are run together.
If operating in script mode then a set of jobs will be defined in a script file.
If operating in GUI mode then a <b>Job Set</b> is used to identify
a group of jobs to be run together.
In both cases the jobs will be run sequentially, one at a time.
In the case of a script the sequence is controlled by the order of the 
lines in the script file.  In the case of a <b>Job Set</b> 
the sequence is controlled the the <b>Order</b> field on the <b>Job</b>.
Once all jobs in the script or job set complete the application will end
<b>unless</b> there are <b>Poll</b> jobs.
If there are <b>Poll</b> jobs in the script or job set then the application
will sleep for a while, then awake and run the <b>Poll</b> jobs again, 
and then go back to sleep.</p>

<h2>Load Job</h2>
<p>A <b>Load</b> job is a job which does the same thing every time it runs.
You can use specify a <b>Condition</b> field to restrict which records are loaded.
You can also specify a <b>date interval</b> based on
<name>sys_created_on</name> or <name>sys_updated_on</name>.
The date interval will not be updated automatically by the application.
In other words, if the job is run multiple times, the date interval will
be the same each time the job is run.
</p>
<p>Use a <b>Load</b> job for the following cases:</p>
<ul>
<li><join>You are performing a one-time initialization of a table. 
Once the job completes it will not be run again.</join></li>
<li>You have a table which is periodically reloaded in its entirety.</li>
<li><join>You periodically load a set of records into a target table using a 
filter condition, but the filter condition does not change with each run.</join></li>
</ul>
<p>When you define a <b>Load</b> job you have the option of specifying 
a <b>Truncate</b> option.
If <b>Truncate</b> is specified then the target table will be truncated before the load begins.</p>

<h2>Load Method</h2>
<p>A <b>Load Job</b> can specify a <b>Load Method</b>.  
If <b>Truncate</b> is false then you can choose one of three load methods.</p>
<ul>
<li><join><b>Update Insert</b> - This is the default. 
Records in the target table will be updated using the primary key 
(<name>sys_id</name>).
If they do not exist they will be inserted.</join></li>
<li><join><b>Insert Only</b> - Records will be inserted in the target table.  
If a record already exists then an SQL Primary Key Violation will be thrown 
and the application will abend.
This method should only be specified if you have reason to expect
that the target records do not exist.</join></li>
<li><join><b>Compare Timestamp</b> - The timestamp (<name>sys_updated_on</name>) from ServiceNow 
will be compared with the timestamp (<name>sys_updated_on</name>) of the target table.
If the ServiceNow record is more recent then the target table will be updated or inserted.
This method may be selected if, for any reason, you wish to avoid updates 
to unchanged records.</join></li>
</ul>
<p>If <b>Truncate</b> is true then the load method is automatically <b>Insert Only</b>.</p>

<h2>Refresh Job</h2>
<p>A <b>Refresh</b> job loads records which have been inserted or updated since the job ran last.
When using GUI mode, the application will advance the job interval each
time the "Refresh" job is run.  
The ending datetime from the last run becomes the starting datetime for the current run.
The ending datetime for the current run becomes the current datetime.</p>
<p>When using <b>Script</b> mode, a <b>Refresh</b> job
provides no more additional functionality than a <b>Load</b> job, unless 
polling is activated.</p>
<p>Note that the date interval is half-inclusive.
The starting datetime is included in the query.
The ending datetime is excluded.</p>  
<warning><b>Refresh</b> jobs may adversely affect the performance of your system
if <name>sys_updated_on</name> is not an indexed field in the specified table.
Contact ServiceNow Customer Support to add indices to your instance.</warning>

<h2>Prune Job</h2>
<p>A <b>Prune</b> job reads the <name>sys_audit_delete</name> file to identify
any records which have been deleted in ServiceNow since the last run.
These records will be deleted in the target table.</p>
<warning><b>Prune</b> jobs may adversely affect the performance of your system
if <name>tablename</name> and <name>sys_created_on</name> are not an indexed field in the 
<name>sys_audit_delete</name> table.
Contact ServiceNow Customer Support to add indices to your instance.</warning>

<h2>Polling Option</h2>
<p>A polling option is available for <b>Refresh</b> and <b>Prune</b> jobs.
In <b>Script</b> mode the polling option is activated by adding an <name>every</name> clause
to the <name>refresh</name> or <name>prune</name> command.
In <b>GUI</b> mode the polling option is activated by setting <b>Poll Continuously</b>
to true.
The polling option causes the application to sleep, awake and repeat
the job at a periodic frequency.  If a polling option is specified
then the application will continue running until it is cancelled or killed.</p>
<p>It is possible to have multiple jobs in a single script with different 
polling frequencies.  Since the application is single threaded
and only runs one job at a time, a job may need to wait longer than 
its configured frequency before running.</p>
<warning><b>Polling</b> jobs may adversely affect the performance of your system
if the proper fields are not indexed in your ServiceNow instance.
Refer to the notes above regarding indices for Refresh and Prune jobs.</warning>

<h2>Backloading Historical Data</h2>
<p>When using ServiceNow
<link url="http://wiki.servicenow.com/index.php?title=Direct_Web_Services">
Direct Web Services</link>, there are two ways to retrieve a large number
or records from a table.</p>
<ul>
<li><p><b>getKeys</b> &#x2014; Use the <code>getKeys</code> method
to retrieve the keys of desired records, then fetch the records in chunks
using an encoded query of the form <code>sys_idIN</code><var>sys_id,sys_id,...</var></p></li>
<li><p><b>windowing</b>  &#x2014; Use the <code>__first_row</code>
and <code>__last_row</code> parameters to fetch the records in chunks.</p></li>
</ul>
<p><b>GUI Mode</b> supports both methods.  
<b>Script Mode</b> currently supports only the first method (<b>getKeys</b>) 
since our testing indicates that the performance is better.
There is an up-front hit on the <b>getKeys</b> call, 
but all subsequent SOAP requests will run faster.
However, this method can be problematic if the result set is too large,
as the initial <b>getKeys</b> call may never return.</p>
<p>The solution is to break up the request into a number of smaller requests
by date (typically using <name>sys_created_on</name>).
A number of smaller jobs are created.  
Based on the transaction volume, these may be by month or by week.
If the transaction volume is especially high then it may be necessary to create
a job for each day. If the volume is low then one job per quarter may be sufficient.
We typically try to keep the size of a job to under 50,000 records.</p>
<p>When using the DataPump in <b>Script Mode</b>, use your favorite
scripting tool or text editor to create a script file containing a bunch of load jobs.
If using the DataPump in <b>GUI Mode</b>, use a UI action to clone the a load job.
Create one load job for the first month, then clone it 23 times to load two years
worth of data.  Kick off the jobs on a Saturday afternoon when system activity is at an ebb,
and within a few hours the data will be loaded.  While this approach may seem a bit 
tedious, it is important to remember that it is a one-time process.  
Once the history has been loaded into the data mart, it never needs to be loaded again.
Going forward we load recent activity at regular intervals, and the transaction
volumes are much more managable. 
</p>

</doc>